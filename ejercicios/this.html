<html>

<head>
    <title>This</title>
</head>

<body>
    <a href="/ejercicios/">Go back</a>
    <p><em>Abre la consola</em></p>
    <h1>
        <code>This</code> se refiere a un objeto. Ese objeto es el que actualmente esta ejecutando un pedazo de codigo.
    </h1>

    <script>
        //this en el global scope
        console.log(`this es igual a ${this}`); //en consola nos sale que this es un objeto y ese objeto es windows
        //siempre que usemos this en el global scope el browser lo va a asignar a windows

        //this en el scope de una funcion 
        function whoIsThis() {
            return console.log(`this en una funcion es ${this}`)
        };

        whoIsThis();
        //en este caso nos dice que this tambien es un objeto y ese objeto es windows

        //this en el scope de una funcion usando strict mode

        function whoIsThisStrict() {
            'use strict'; //con esto ya estamos usando el modo estricto se puede usar dentro o fuera de una funcion
            return console.log(`this en una funcion estricta es ${this}`)
        };

        whoIsThisStrict();
        //en este caso nos dice que this esta undefined ya que strict mode nos ayuda a evitar errores comunes que
        //cometemos los programadores  el motor de js nos va mostrar esos errores en desarrollo y no en produccion

        //this en el contexto de un objeto
        const person = {

            name: 'carlos',
            saludar: function() {
                return console.log(`hola que tal como estas ${this.name}`);
            }

        }

        person.saludar();
        //en este caso this saluda a carlos porque la funcion la ejecuta un objeto que es person y dentro de saludar esta this
        //y this se refiere al objeto que actualmente esta ejecutando el codigo por lo tanto this hace referencia a toda el objeto


        //this cuando sacamos una funcion de un objeto

        const action = person.saludar; //no la ejecutamos solo le pasamos el saludar a action
        //ahora invocamos a action 
        action(); //esto saluda a nadie porque action no se esta llamando en el contexto de un objeto
        //simplemente se esta llamado similar a la funciones anteriores
        //el return de la funcion se queda corto porque this no existe

        //this en el contexto de una "clase"

        //las clases como tal no exixten pero resultan llamarles clases a estas funciones especiales que llamamos 
        //con new

        function Person(name) { //name es el argumento
            //this = {} this al inicio es este no se puede hacer directamente en si
            this.name = name;

        }
        //esta funcion funciona como un constructor todas las funciones tienen un this loq ue sucede es que el valor es un objeto vacio
        //no puedes asignar un this en si si no que tienes que asignale una propiedad de this 

        //cuando tenemos estas clases estos objetos que se comportan como clases si queremos darles uyn metodo los hacemos atraves de su prototype
        Person.prototype.saludar = function() {
            return console.log(`Mi nombre es ${this.name}`);
        }

        //ahora hay que crear una instancia de person
        const carlos = new Person('carlos');
        //luego llamamos al metodo saludar de la persona carlos
        carlos.saludar();

        //en el contexto de objetos que fueron instanciados de una clase this se va referir a la instacia de este objeto
        //no se va referir a person ni a person.prototype en este caso carlos esta ejecutando a saludar
    </script>
</body>